---
title: Как победить функциональную кодобазу
author: Денис Редозубов, @rufuse, CTO @ typeable.io, @typeableIO
patat:
    incrementalLists: true
    wrap: true
    theme:
        emph: [vividBlue, onVividBlack, bold]
        imageTarget: [onDullWhite, vividRed]
...

# Как победить функциональную кодобазу

И правда, как?!?!

Как размышлять о разработке, чтобы кодобаза жила долго и её можно было править?

---

# Ccылка на слайды

https://github.com/dredozubov/fpconf16

---

# Disclaimer

Язык программирования не принципиален, чтобы извлечь что-то из этого рассказа.
Я дам мало ответов, но зато у вас появится больше вопросов, которые можно у себя регулярно спрашивать.

---

# История кодобазы

- 1 317 481 правок
- 70+ kLOC
- Haskell

---

# Что пишет код за нас

- TH
- Generics

---

# Программист - человек.

Помним про свои естественные ограничения.
Человек способен держать в своей голове ~5 концепций одновременно.

---

# Что такое рефакторинг?

Преобразование программы `Source -> Source`, сохраняющее текущую семантику.

---

# Неформально про рефакторинг

Процесс, позволяющий поддерживать адекватный уровень:

- абстракции
- инкапсуляции
- логики
- гигиены

---

# Для чего рефакторинг делается

- чтобы упростить грядущие доработки
- чтобы сделать чужой код понятным для себя - переписывание с помощью своих идиом

---

# Идиоматический рефакторинг

```
               ^
               |Рак
        +------------+
  Лебедь|            | Рак
 <------+            +----->
        |   Код      |
        |            |
        +------------+
               | Щука
               v

```

---

# Идиоматический рефакторинг

Строим гайдлайны для написания кода и общую культуру!

Нужно ли его когда-либо делать? Да, постепенно с принятием командой новых идиом в проекте.

---

# Идиоматический рефакторинг 2: восстание стиля

Стиль кода - bikeshedding-генератор.
Чтобы не было споров, диктатор выбирает один стиль и формализует правила.

---

# Структурный рефакторинг

- Абстракция
- Специализация

---

# Абстракция или специализация

Основной вопрос:
Сколько у кода потребителей?

Premature abstraction и premature specialization - черная дыра для времени.

---

# Libraries

Максимальный уровень абстракции и code reuse.
Как библиотека будет использоваться пользователями - открытый вопрос.

---

# Business applications

Приложение реализует какой-то процесс, который как правило, лишь частично специфирован.
Специфицированная часть должна результировать в специализированный код, в противопоставление полиморфному и абстрактному.

---

# Абстракция

If you think you can create abstractions which don't leak, remember: even atoms aren't atomic. (C) @extempore2

---

# Как еще можно рефакторить?

Рефакторинг пакетной структуры и зависимостей.

Рекомендации очевидные - использовать поддерживаемые и проверенные внешние зависимости.
Если библиотека достаточно понятна и мейнтейнер отзывчив - это хороший знак.

Внутренние - отдельный разговор.

---

# Рефакторинг типов

Создание отдельных типов для разных концепций, имеющий одинаковое "внутреннее" или "машинное" представление.

```
newtype Quantity = Quantity { fromQuantity :: Int }

newtype SlotId = SlotId { SlotId :: Int }
```

---


# Рефакторинг типов (2)

- `神秘 :: (t -> ((a -> m r) -> m r)) -> ((t -> w) -> (w -> m w) -> m w) -> ((a -> m r) -> m r)`

- `神秘 :: (t -> K w a) -> ((t -> w) -> K w w) -> K w a`

---

# Рефакторинг типов (3)

`Proxy pointer` может быть гораздо более говорящим для нового "читателя", чем `Proxy p`

---

# Types vs Tests

Типы позволяют покрыть часть инвариантов "by construction":

```
type Passengers = NonEmpty Passenger
```

vs

```
type Passengers = [Passenger]
```

---

# Types vs Tests (2)

Тесты позволяют покрыть те свойства, которые не были покрыты типами

```
any isAdult passengers && all (olderThan 2) passengers
```

Property-based testing очень хорош!

---

# Types vs Tests (3)

Это симбиоз, а не противостояние. sweet spot посередке.

---

# Рефакторинг модульной структуры

Импорты модулей являются стрелками в направленном графе зависимостей внутри вашей кодобазы.
Всякий раз как вы меняете содержимое модулей, вы можете сломать импорт каких-то имён, ломая код.
Задача сводится к тому, чтобы снизить количество ломающихся импортов.

---

# Разумные метрики для импортов

Уменьшение количества путей между каждой парой точек.

---

# Рефакторинг модульной структуры (2)

```
+-------------+
| Module API.A<------------------+
|             |                  |
| foo         |                  |
| bar         |   +----------+  ++----------------------+
|             +^--+module API|  |module APIClient       |
+-------------+   |          |  |                       |
                  |foo       |  |imports API (foo, quuz)|
                  |quuz      |  |imports API.A          |
+-------------+   |...       <--+  (bar)                |
| module API.B+^--+          |  |                       |
|             |   +----------+  +-----------------------+
| quuz        |
|             |
|             |
+-------------+
```

---

# Рефакторинг модульной структуры (3)

- `import A`
- ```
import A.Internal1
import A.Internal2
-- ...
import A.Internal20
```

---

# Рефакторинг модульной структуры (4)

Контрпример:

```Haskell
import Control.Monad
```

и

```Haskell
import Control.Monad.Reader
```

Почему последний тянет часть определений из первого?

---

# Рефакторинг модульной структуры (4)

Программируем сегодняшний код, а не завтрашний.
Вызываем хелпер в одном месте - оставляем там же. В крайнем случае пишем FIXME с пояснениеми и едем дальше.

---

# Qualified vs Unqualified

Qualified-импорты делают код более шумным. Если у вас клэш имен, сперва стоит попробовать:

- `import Mega.Cool hiding (b)`
- `import Mega.Cool as MC`

---

# Почему мы все еще говорим про рефакторинг?

Цена изменения кода - метрика, которую мы хотим удешевить в долгосрочной перспективе.
Рефакторинг - путь для достижения низкой цены изменения.

---

# Спасибо!

Сейчас можно задавать вопросы.
